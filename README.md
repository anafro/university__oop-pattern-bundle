[![This is a repository for a university task! I am kindly asking you not to review it until it will be converted to a standalone project, if it’ll.](https://github.com/anafro/anafro/blob/main/Banners/Github.Warning.University.png?raw=true "Click to open the list of the portfolio projects")](https://github.com/anafro/anafro/blob/main/Pages/portfolio-project-list.md)

# Описание реализаций паттернов для Константина

* Порождающие:
  * Singleton: класс Application (тут должно быть всё понятно)
  * Builder: класс UserBuilder (тут должно быть всё понятно)
  * Prototype: класс Food - в Java можно клонировать объекты, используя интерфейс `Cloneable<T>`. С помощью метода `clone()` можно создать прототип.
  * Factory: класс AnimalFactory (тут должно быть всё понятно)
* Структурные:
  * Adapter: класс StringJoinerServiceAdapter - в качестве расширяемого класса берём недоступный для изменения класс StringJoinerService. Допустим, это какая-то библиотека, которая склеивает массив строк с единую строку. А мы такие: "Хм, а у нас не массив строк, а просто данные в строке, записанные через запятую :(". Ну тип и всё, сделали свой `join()` в адаптере, который приводит данные, используемые в нашей программе, к виду, подходящему для либы.
  * Bridge: класс Cooker - это мостик между моим желудком и микроволновкой. Мне не нужно задумываться, как он будет че там готовить да, я просто даю ему еду и такой "На, погрей её в микроволновке пж". И он греет, при этом зная, какие настройки нужно включить у микроволновки в зависимости от типа еды.
  * Composite: класс Broadcaster - он рассылает сообщение всем пользователям, записанным в список броадкастера.
  * Decorator: класс IntegerString - расширяет возможности обычной строки, добавляя метод преобразования к числу.
  * Facade: класс Reader - у нас есть 2 источника данных - Интернет и файлы. Чтобы каждый раз не заморачиваться со всеми тонкостями чтения данных с определенного источника, у класса Reader будет такой же метод `read()`, как и у `FileReader` и `UrlReader`, но он будет сам определять источник данных.
  * Flyweight: класс Apple _(ru.anafro.entities.Apple)_ - яблок много не бывает! Если их должно быть много, то мы можем их сгенерировать в `AppleGenerator`, используя одинаковые для них данные о цвете и сорте из `AppleContext`, при этом данные не будут копироваться, что сэкономит кучу памяти.
  * Proxy: класс BankProxy - допустим, `RealBank` - это какая-то апишка банка. Она не всегда может быть доступна, поэтому, чтобы заменить её в коде, можно использовать BankProxy.
* Поведенческие
  * Action: интерфейс TextEditorAction - это какое-то действие в текстовом редакторе. Например, я реализовал 2 действия в соответствующих классах - Сохранение и Очистка.
  * Chain of Responsibility: класс MaterialHandler - у нас есть бумажная фабрика, которая сначала из брёвен делает древесину, затем из неё целлюлозу, а потом бумагу. Такими преобразованиями занимается `MaterialHandler`.
  * Iterator: класс StringList - в Java итераторы можно реализовать только через интерфейс `Iterable`.
  * Mediator: класс Airport - аэропорт получает запросы от самолётов на посадку. Аэропорт смотрит, есть ли свободные посадочные полосы, не случилось ли ничего нештатного и т.д. (эта логика должна быть прописана в `isLandingAvailable()`), и если садиться можно, то он приказывает самолёту сесть, иначе уйти на второй круг. При этом самолёты между собой напрямую не взаимодействуют.
  * Observer: класс YoutubeUser - на какой-нибудь канал на ютубе публикуется видео, а все его подписчики получают о нём уведомление.
  * Snapshot: класс TextEditorSnapshot - если мы хотим сохранить нашу работу с документом в текущем моменте, то есть сохранить содержимое и позицию курсора в файле, мы делаем снимок объекта. После из этого объекта можно создать объект `TextEditor`-а
  * State: класс PhoneState - при разных состояниях смартфона он реагирует на нажатие боковых кнопок по-разному. Это описано в каждом наследнике `PhoneState`.
  * Strategy: интерфейс SortingAlgorithm - в нём должен описываться алгоритм сортировки массива. Отсортировать массив можно разными способами, что описано в реализации интерфейса в классах `Merge-` и `QuickSortAlgorithm`. `Array` же использует алгоритм, не зная, какой именно.
  * Template Method: интерфейс ProgramExecutor - чтобы запустить код на разных языках программирования, нужно разные способы сборки, компиляции и запуска. Для обобщения, создан этот интерфейс. Его реализует несколько классов для соответствующих типов программ соответственно.

:)
